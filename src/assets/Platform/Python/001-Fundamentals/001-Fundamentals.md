
# Hello, (Python) World!

## Objectives:

-   Why is Python a good choice for someone's first programming language?
-   Cover the basic goals and schedule for the next four weeks.

----------

## Welcome


## Course Outline


<iframe width="560" height="315" src="https://www.youtube.com/embed/DRoHzLNipkI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

##

Before we get started, we wanted to give you a subjective idea about how difficult each day will be in relation to the Belt Exam. ***Note the actual stress level varies by student, but this is our experience in teaching the stack.***

<img src="https://i.ibb.co/RStwR7r/python-Student-Stress-Curves.png" alt="python-Student-Stress-Curves" border="0">

Let's get started by taking a tour of where we'll be going over the next four weeks. The terms in bold indicate important topics you'll learn more about later.

**Important!**  This schedule is subject to some adjustment. We'll always stick to a similar outline, but we also frequently adjust our schedules from group to group to allow more time with particular topics as demand dictates. Ask your instructor for a more precise schedule, including lecture topics and times.

-   **Part 1: Python + Python OOP**
    -   Installation
    -   Fundamentals:
        -   Spend 2 days learning  **syntax**. Syntax simply means the vocabulary of the language.
        -   Practice the fundamentals of programming that you've been using in your morning algorithms.
    -   Object Oriented Programming:
        -   Learn OOP, a style of organizing your code that is prevalent in web development.
        -   Don't underestimate how important it is to develop a solid understanding of OOP, which is a pivotal skill. This is why you spend the rest of your time at the bootcamp building on your understanding.
        -   Frameworks like Django, Rails, Angular, and iOS are built using an  **object oriented design pattern**.
-   **Part 2: Flask + MySQL**
    -   Intro to Flask:
        -   Learn how to make a web server using the Flask  **framework**. You'll create web pages that can accept data sent from a client and return a response. This quick intro will take about 2 days.
    -   MySQL:
        -   Spend 2 days learning about MySQL, a commonly used  **relational database**.
        -   Learn to create visual representations of your database.
        -   Formulate  **SQL queries**  using database creation and management software.
    -   Flask + MySQL:
        -   Extend your use of Flask to include  **data persistence**  using a database as storage.
        -   Challenge yourself to complete The Wall, an assignment that brings together all the skills and tools you've learned so far.
        -   Spend two days completing this section.
-   **Part 3: Django + Belt**
    -   Django:
        -   The framework you've all been waiting for!
        -   You will learn and use  **code modularization**  to organize your code according to the purpose it serves.
        -   Learn to build a project in Django.
        -   Move on to Django. You'll spend more time with Django than any other Python section. Spend the next 6 days learning this powerful framework.
        -   Learn to store data in a  **SQLite database**.
        -   Learn to use an **object relational mapping**  (ORM) to communicate with your database.
-   Deployment:
    -   Learn to move your code (previously hosted on your computer) to the web so everyone can see the product of your hard work!
-   Belt Exam:
    -   On Friday of week 3, you'll be ready to take your first full-stack belt exam!
    -   Your instructor will give you more details as the date approaches.
    -   Try not to worry about this for now. The exam is low-pressure and can be retaken.
    -   The exam is open-web – meaning you have all of your previous code and the entire internet at your disposal!
-   **Part 4: Belt Retake + Projects**
    -   Retake your belt exam if needed
    -   Do a project:
        -   After passing your belt exam, you're ready to do a project!
        -   Your project is your motivation to earn your belt. Complete your belt quickly in order to spend as much time as possible working on a fun project. Ask your instructor for project ideas if you need help.
        -   Create anything you want using your new skills. The sky's the limit!

# Why Python?

## Objectives:

-   Why is Python a popular programming language?
-   Why is Python a great choice for beginning programmers?
-   What is the core philosophy of Python?

----------

**Python**  was designed by Guido van Rossum and first became available for use in 1991. Python is a great first programming language because its syntax is not complicated when compared to many other languages. This will allow you to focus on learning programming concepts rather than complicated language. Writing code in Python is remarkably similar to the pseudocode you've already been writing in your morning algorithm class.

One important thing to remember is that Python's simplicity relies upon proper indentation, which you'll find helps you to write more clean and readable code. You've been introduced to proper indentation already, but you'll soon learn why Python requires it.

<img src="https://i.ibb.co/bzVHjbH/parsertongue.jpg" alt="parsertongue" border="0">

## Why Python?

Here are some reasons why people in the development community think Python is great!

-   **Readability**  - Python's syntax closely resembles English with punctuation rules that promote consistent format.
-   **Libraries**  - Python has been around for more than 20 years. There are tons and tons of resources and libraries that you can take advantage of. If you can think of a task for which you'd like to use Python there is probably a library out there that a skilled developer made just for that purpose.
-   **Community**  - It helps to ask others about things you're not sure of or problems that you just cannot get around. There is a massive community built around Python development built by people who are enthusiastic about Python and always happy to lend a hand!
-   **Scope**  - Python is effective across a broad range of project types - scientific computing, data analytics, machine learning, game creation, web development, and more!
-   **Ease**  - Python has earned a reputation for being easy to learn due to the simplicity of its syntax. It is now the most popular language taught at top universities for instruction on fundamental and advanced computing concepts

Here are some apps you may have heard of that were built using Python for some or all of their backend code:

-   YouTube
-   DropBox
-   Google
-   Quora
-   Instagram
-   Spotify
-   Reddit
-   Pinterest

## Core Philosophy

The core philosophy of the language is summarized by the document "PEP 20 (The Zen of Python)":

-   Beautiful is better than ugly.
-   Explicit is better than implicit.
-   Simple is better than complex.
-   Complex is better than complicated.
-   Readability counts.

You can read the full version here: [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)  (or type "import this" into the Python interactive console).

## Why Python is Good For You

1.  **Popular:**  plenty of community support
2.  **Shallow learning curve:**  easy to learn
3.  **Minimal setup:**  quick to get started
4.  **Understandable:**  code is written in plain English
5.  **Fast development cycle:**  get something going fast; optimization is available later if needed

## Python 2 or 3?

For our Python and Django course, we will be using Python 3.

You might be wondering why it's even up for discussion whether to use Python 2 or Python 3. Here's why:

-   Many companies are still using 2.7.x, meaning that many Python developers use 2.7 at work. There are many reasons why this is the case, the primary being the expense of switching all of a company's code base from one version to another.
-   Python 3.x is not backward compatible with 2.x - you can always migrate forward to 3.x

Python 3 is gaining popularity, but chances are, you'll soon find yourself needing Python 2.7. The differences are easily overcome, and as long as you learn one version well, you'll be able to move between the two without much trouble. If you're curious, you can read about the differences  [here](http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html). Don't spend more than 10 minutes reading this; you can come back to it later. Much of it won't make sense quite yet.

The change that will probably encounter most frequently as we're learning Python is the  `print()`  function. As you're scanning code snippets in Stack Overflow or looking up different Python libraries, it is an easy way to identify if the person is using Python 2 or Python 3. In Python 3, it is a function. To print a string, you'll use parentheses:
```python
print("Python 3's print is a function!")
```
However, in earlier versions of Python,  `print`  is a statement, and therefore does not require parentheses:
```python
print "Python 2.7's print is a statement!"
```
Including parentheses in earlier versions of Python will not cause any problems, but forgetting them in Python 3 will throw a syntax error.

# Installing Python 3 (Mac users only)

## Objectives:

-   Install Python 3 on your computer for Mac users

----------

To install Python, we will use  _homebrew_, which is a package manager that helps us install software on our operating system. You may have installed homebrew already. To check, run this command in your terminal:
```shell
~$ brew -v
```
If you get an error, go to  [brew.sh](https://brew.sh/)  and follow the instructions for installing homebrew.

Now that we have homebrew working, we can install Python:
```shell
~$ brew update		    # update homebrew
~$ brew install python3	    # install Python 3
```
Updating and installation might take a few minutes. If there are any other problems, homebrew helps us out by telling us certain commands we might need to run to properly install things. Read through the outputs and run the recommended commands. Otherwise, we can check the version to see if it installed:
```shell
~$ python3 -V         # type this command
```
You should see a version number like  `Python 3.6.5`  (version numbers may be slightly different). If you get an error, consult with your instructor.

# Installing Python (Windows users only)

## Objectives:

-   Install Python 3 on your computer for Windows users.

----------

To install python, we will download Python directly from Python's website with this link:  [Python 3.6.4](https://www.python.org/downloads/release/python-364/)

The installer application will configure our system PATH variable so that we can run the `python` command from anywhere in our terminal. It will also set a PATH for additional development software, such as `pip`, so that we can run those commands as well.

Take note of where your Python files are being downloaded to, as you may need to refer to this location if you wish to set your PATH at a later date.

<img src="https://i.ibb.co/bmnQG2j/python-3-install-edit.png" alt="python-3-install-edit" border="0">

We can check the installation and version in our terminal to see if it worked:

<img src="https://i.ibb.co/xX0CMcm/python-version.png" alt="python-version" border="0">

If you got an error after running the command above, consult with your instructor.

# Windows Users: To git bash or not to git bash?

## Objectives:

-   Be aware of the differences between command prompt and git bash

----------

**Git bash is known to have issues running Python on a Windows machine. You're less likely to get bugs with the command prompt, so that's what we recommend.**

However, if you're more comfortable operating in a Linux-like environment, you can use a bash shell like git bash, which you may have been using since Web Fundamentals. If you choose to do so, you will likely encounter strange behaviors when running Python. We'll talk about two of the most common errors so you'll be prepared if you decide to continue to use git bash.

#### Issue #1: Python Shell hangs on initialization

If you type the  `python`  command in git bash and you see your cursor move down a line but nothing else happens, you've encountered a known problem relating to a software dependency called ncurses. The best way to solve this problem is by adding an alias to your  `.bashrc`  file. From your bash shell:
```bash
cd ~
touch .bashrc
start .bashrc
```
Now with your file open, add this line:
```bash
alias python='winpty python.exe'
```
Then, close and re-open git bash.

#### Issue #2: Print statements do not appear

This is a known problem and has yet to be corrected. There are two good workarounds. If you're running Python in shell, you'll have to flush the output buffer after each print statement. This line does the trick:  `sys.stdout.flush()`. If you're running the code from a document using the  `python filename.py`, just modify this to  `python -u filename.py`.

# Organizing Files

## Objectives:

-   Set up a folder structure to keep our Python files organized

----------

Throughout this month, we are going to be creating a lot of projects! To stay organized, let's set up a folder structure where we can keep all of the assignments we'll be doing during this Python track.  **Tip: Don't give your files or folders names with spaces in them!**  We recommend having a folder structure like this, that follows along with the chapters throughout the track:

-   python_stack
| -   | -- my_environments |
| --- | ------------------ |_python (the underscore IS IMPORTANT)
    -    |-- python_fundamentals
    | -   | -- OOP |
    | --- | ------ |django
    -    |-- django_fundamentals
    | -   | -- django_orm |
    | --- | ------------- |django_fullstack

  

  

- [ ]  Create a folder structure for Python assignments and projects

# Package Manager: pip

## Objectives:

-   What is a package?
-   What is a package manager?
-   Practice installing and uninstalling packages with the Python package manager

----------

Even though programming languages come with a lot right out of the box, you'll find yourself wanting to use some functionality that is not included in your language's standard library. For example, since Python can be used for more than just web development, web functionality does not come pre-loaded when we install Python. However, other developers have created  **packages**  that we can download so we don't have to reinvent the wheel.

Pip is the  **package manager**  we'll use in Python to install these third-party packages. (There are other package managers, but for simplicity and fewer installations, we're sticking with pip because it was included when we installed Python.) Rather than having to go search for packages and versions ourselves, package managers are generally able to find the versions we need with just a single command from our end. That command will look like this:

```bash
-------------------------------------------------
| Mac/Linux: | $ pip3 install {{package}} <= NOTE: substitute {{package}} with the package you are installing
-------------+-----------------------------------
| Windows:   | $ pip install {{package}}   
-------------------------------------------------
```
As an example, the output will look something like below if we were to install Django:

<img src="https://i.ibb.co/qR88qGX/add-to-path.png" alt="add-to-path" border="0">

To uninstall a package, we run this command:
```bash
-------------------------------------------------
| Mac/Linux: | $ pip3 uninstall {{package}} <= NOTE: substitute {{package}} with the package you are removing
-------------+-----------------------------------
| Windows:   | $ pip uninstall {{package}}    
-------------------------------------------------
```
If pip/pip3 isn't recognized, you may have to add it to your path:

<img src="https://i.ibb.co/5Lb6prW/Screen-Shot-2018-03-20-at-5-56-54-PM.png" alt="Screen-Shot-2018-03-20-at-5-56-54-PM" border="0">

We'll use this installation process in the next tab.
# Virtual Environments

## Objectives:

-   Understand what virtual environments are and how they are useful
-   Set up a virtual environment
-   Know how to use a virtual environment

----------

You may have noticed that when we installed a package using pip, it was installed globally on our machine. While this is okay, if we're working on multiple projects, it might be hard to keep track of which projects are using which packages, or in other words, which projects have which  **dependencies**. To keep this organized, Python uses  **virtual environments**.

In addition to specifying what packages we need, we can also specify which version of Python to use in a given environment. This allows us to have multiple versions of Python installed on our computer and then easily switch between versions when actually running and testing our code.

In practice, because your projects will be larger, it's good to create virtual environments specific to a project. However, while you're here at the Dojo, you'll be creating dozens of projects in the next month that just have a few dependencies, so we'll just set up two environments, just to get some practice using them: in one, we'll install Flask, and in the other Django.

Let's try it out!

We need a place to store these environments. Remember the  _my_environments_  folder we created in the first assignment? Let's store our environments there. In the terminal, navigate (`cd`) to the my_environments directory. Next, decide on a name for your environment (it can be whatever you'd like). In this example, we're naming our environment  _py3Env_. Here's the command to create the virtual environment with that name:
```bash
------------------------------------------------------------------
| Mac/Linux: | python3 -m venv py3Env                     
-------------+----------------------------------------------------
| Windows:   | python -m venv py3Env               
------------------------------------------------------------------
```
We should now see a new folder in our previously empty my_environments directory called py3Env.

#### Activating a Virtual Environment

The keyword for activating a virtual environment is  `source`  or  `call`, depending on which OS and terminal we're using. We run this command and specify which environment to activate like so (the following assumes we are in the my_environments directory, with a virtual environment called py3Env):
```bash
------------------------------------------------------------------
| Mac/Linux: | source py3Env/bin/activate                         
------------------------------------------------------------------
| Windows command prompt : | call py3Env\Scripts\activate       
------------------------------------------------------------------
| Windows git bash : | source py3Env/Scripts/activate         
------------------------------------------------------------------
```
We know our virtual environment is active, and which virtual environment is active, when the command line changes to something like this:  
```bash
(py3Env) $
```
If you want to check what packages are installed in a given environment, try running `pip list`  with the environment active.

#### Deactivating a Virtual Environment

To deactivate a virtual environment, just type  `deactivate`  in the command line. Closing your terminal window will also deactivate your virtual environment.

If these ideas are still a little bit fuzzy, here's a video to see these commands in action:

<iframe width="560" height="315" src="https://www.youtube.com/embed/bRsa0vy1nx8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

# Assignment: Practice using pip in a virtual environment

## Objectives:

1.  Get accustomed to using commands required to use pip modules
2.  Practice using a virtual environment

----------

You will need to use your terminal to run these commands. Open up terminal, command prompt, or git bash to continue.  **Activate your virtual environment before running any of these commands!** Remember that you can tell whether your virtual environment is activated by the prompt in your terminal. Here, we can see that the virtual environment py3Env is activated:

<img src="https://i.ibb.co/3FcswCS/Screen-Shot-2018-03-20-at-6-58-31-PM.png" alt="Screen-Shot-2018-03-20-at-6-58-31-PM" border="0">  

Run these commands in the order instructed. Your assignment submission should be a .txt file that includes a short explanation of what you were able to learn about each command by doing a brief (1-2 min) web search for each term. If it is relevant, include the output of your command and your understanding of what it means. It is important to always read your terminal output and try to understand it.

Reminder: when your virtualenv is activated, you may use the  `pip`  command. If not, use  `pip3`.

**Run the following commands:**

`pip list`

`deactivate`  (This will deactivate your virtual environment)

`pip3 list`  (How is the result different from when you ran  `pip list`  with the virtualenv activated? Hint, you should not have as many things listed when the virtualenv is deactivated. If your results are the same, go back and figure out what went wrong.)

`source myEnvironments/py3Env/bin/activate`  (Adjust the path as needed to  **re-activate the virtualenv**; for windows  `call myEnvironments/py3Env/Scripts/activate`)

`pip install Django==2.2.4`  (What information do you see returned in terminal after this command?)

`pip freeze`  (What's the difference between freeze and list?)

First cd into your Desktop directory (`cd ~/Desktop`), then run this command:  `pip freeze > requirements.txt`. What do you see when you  `ls`? What's inside this file?

`pip uninstall Django`

`pip show Django`

# Running Python

## Objectives:

-   Understand how to use the Python shell to run basic python codes
-   Understand how to create a file and use Python to execute the file

----------

There are 2 ways to execute Python code. For most of the course, we'll be working with Python files, but it's good to know about the shell, especially for testing small snippets of code.

### The Python Shell

A  **shell**  is simply an interface for interacting with services on our computer. Up to this point, we have been using the terminal or command prompt as a shell to interact with all the files and services on our computer.

We can turn our terminal into a shell for Python by typing  `python` (or maybe  `python3`) in our terminal.

What is the  _Python shell_? The shell is a command line interface we can use to interact with the Python interpreter. Similar to how we were able to use our web browser's console to run JavaScript, the Python shell allows us to run Python code in our terminal. Once activated, we can type some Python code and see the results immediately. Let's try it out by simply typing  `python`  in our terminal:

<img src="https://i.ibb.co/LYnTGBM/Screen-Shot-2018-03-21-at-1-49-28-PM.png" alt="Screen-Shot-2018-03-21-at-1-49-28-PM" border="0">

When we see these  `>>>`, we know we're in the shell. That means it's no longer functioning as our terminal, but will only understand Python code. When we type a statement, the shell will output the result. Try out these commands:
```
>>> 4 + 5
>>> 31/2
>>> x = 9
>>> y = "hello"
>>> x * y		# what do you expect this one to do??
```
To exit the shell, type:  `exit()`.

# Python Files

We just learned how to experiment with Python code in the shell, but as soon as we close the shell, we've lost all of our hard work. Now we need a way of saving our code so we can use it later.

Navigate to the fundamentals directory in the terminal. Create a new file called hello_world.py by running  `touch hello_world.py`  on a Mac or GitBash or  `type nul > hello_world.py`  in a Windows command prompt.

Open the hello_world.py file we just created and add the following line of code and save the file:
```python
print("Hello World!")
```
Now we'll run it from the terminal. If your virtual environment is not yet active, activate it. Then navigate back to the fundamentals directory where we saved our new Python file and run it:  `python hello_world.py`. If you are on a Mac, use `python3 hello_world.py`

The print statement tells the Python interpreter to output whatever follows into the terminal. It's a lot like  `console.log()`  in JavaScript. The terminal output will look like the following:

<img src="https://i.ibb.co/92DM2XJ/Screen-Shot-2018-03-21-at-1-12-57-PM.png" alt="Screen-Shot-2018-03-21-at-1-12-57-PM" border="0">

Let's add some variables along with print statements. Try entering the following in your file and run your file again:
```python
x = "Hello Python"
print(x)
y = 42
print(y)
```
We're ready to get coding!

# Guideline for Assignments

## Objectives:

-   Balance the reading of content with the doing of assignments
-   Understand how to approach assignments
-   Know the importance of optional content for later use (projects/post-graduation)

----------

## Reading vs. Doing

While the reading is important, it is best utilized as supplemental to the actual  _doing_  of assignments. Don't spend too much time trying to understand all the reading prior to starting an assignment. Instead, read through the content for a few minutes to get an idea of what you'll be learning and to have a reference to come back to.  _Definitely code along if there are code blocks, to start seeing the code in action._  Then start working through the assignments. We believe in learning by doing and strength through struggle--as you actually work through the assignments, the content will make more sense because you'll have a context for all the jargon and code snippets.

This methodology is probably contrary to the traditional schooling you're used to, but don't be afraid to jump in and make mistakes. That's where the best learning happens!

## Bonus Challenges and Optional Assignments

The variety of Dojo students' experiences vary greatly. Some of you have come in with some programming experience, and some of you have come in with absolutely none. But all of you have come here to learn and become great developers, and that's our goal for you too. With that in mind, we've tried to add layers of difficulty to many of the assignments.

#### To the Beginner

For those of you who are beginners, don't feel bad if you don't take on the Ninja and Sensei challenges or optional assignments this month. The basic tasks of each assignment are sufficiently designed to build a solid foundation. Know that once you graduate and continue your studies, the extra challenges are a great way to help you level up and keep learning. It'll be a great way for you to see how far you've come in just a few short months!

#### To the Intermediate

If you are able to stay on pace with the assignments each day, take the time to challenge yourself with the Ninja or even Sensei challenges. These are a great way to push you to go beyond what we've explained in the curriculum, to consult documentation and peers, and to help you gain a deeper understanding of the language and frameworks we'll be using throughout the course. As you have time, take on the optional assignments.

#### To the Experienced

If you find yourself finishing each day's assignments early, make sure you complete each Ninja and Sensei challenge, and as many of the optional assignments as possible. We want you to feel confident using the language and frameworks' documentation, understand Stack Overflow, and gain a more comprehensive understanding of the language. Find answers to questions we haven't even asked! This is a great way to solidify your self-sufficiency as a developer and make your portfolio and experience really stand out.

The optional modules and assignments are mainly designed to:

1.  Introduce advanced concepts that may be asked during job interviews. Having exposure to these concepts will help prepare you for those kinds of questions. Again, that is useful upon graduation, so if you are feeling behind, know that you can always come back to these when you really begin preparing for job interviews. Your focus now is learning web development fundamentals!
2.  Introduce cool tools and libraries that can help your portfolio of projects look a lot more impressive. Remember that you'll want a great portfolio if you are looking for a job after the bootcamp. We strongly encourage that some of your projects involve some of the tools or libraries introduced in these optional assignments.

The majority of students do not get to work on most optional assignments during the track. Even those with years of development experience do not finish all of the optional assignments. Once you level up and get your belt, come back and revisit these advanced topics or browse through optional content as you think about what to include in your projects.

# Printing Strings

## Objectives:

-   Recognize various methods for combining variables with literal strings
-   Be aware of commonly used string methods and where to go for more information

----------

### String Literals

Strings are any sequence of characters (letters, numerals, ~($/}\#, etc.) enclosed in single or double quotes. We can display a string like this:
```python
print("this is a sample string")
```
### Concatenating Strings and Variables with the print function

There are multiple ways that we can print a string containing data from variables.

The first is by adding a comma after the string, followed by the variable. Note that the comma is  _outside_  the closing quotation mark of the string. The  `print()`  function inserts a space between elements separated by a comma.
```python
name = "Zen"
print("My name is", name)
```
The second is by concatenating the contents into a new string, with the help of  **+**.
```python
name = "Zen"
print("My name is " + name)
```
There is one other difference between concatenating using a plus versus using a comma, can you find out what it is?

**Hint:**  try concatenating a string with an integer using each method.

### String Interpolation

We can also inject variables into our strings, which is known as  **string interpolation**. There are a few different ways this can be done.

#### F-Strings (Literal String Interpolation)

Python 3.6 introduced f-strings for string interpolation. To construct a f-string, place an  `f`  right before the opening quotation. Then within the string, place any variables within curly brackets.
```python
first_name = "Zen"
last_name = "Coder"
age = 27
print(f"My name is {first_name} {last_name} and I am {age} years old.")
```
#### string.format()

Prior to f-strings, string interpolation was accomplished with the  `.format()`  method. If you're searching online, you will likely find code snippets using this method. To use it, type out the full string, replacing any words that will get their values from variables with  `{}`. Then call the  `format`  method on the string, passing in arguments in the order in which they should fill the {} placeholders. Here's an example:
```python
first_name = "Zen"
last_name = "Coder"
age = 27
print("My name is {} {} and I am {} years old.".format(first_name, last_name, age))
# output: My name is Zen Coder and I am 27 years old.
print("My name is {} {} and I am {} years old.".format(age, first_name, last_name))
# output: My name is 27 Zen and I am Coder years old.
```
The two example print statements are provided to demonstrate that the format method reads the string from left to right, replacing the {} with the value of the arguments provided, in order. This means there should be the same number of sets of {} as there are arguments passed into the function.

#### %-formatting

There is an even older method of string interpolation that you may come across when troubleshooting or researching, so you should know about it. Rather than curly braces, the  `%`  symbol is used to indicate a placeholder, a  `%s`  for a string and  `%d`  for a number. After the string, a single  `%`  separates the string to be interpolated from the values to be inserted into the string, like so:
```python
hw = "Hello %s" % "world" 	# with literal values
py = "I love Python %d" % 3 
print(hw, py)
# output: Hello world I love Python 3
name = "Zen"
age = 27
print("My name is %s and I'm %d" % (name, age))		# or with variables
# output: My name is Zen and I'm 27
```
### Built-In String Methods

We've seen the format method, but there are several more methods that we can run on a string. Here's how to use them:
```python
x = "hello world"
print(x.title())
# output:
"Hello World"
```

<iframe width="560" height="315" src="https://www.youtube.com/embed/Y-TDNzpd6fE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


#### The following is a list of commonly used string methods:

-   `string.upper()`: returns a copy of the string with all the characters in uppercase.
-   `string.lower()`: returns a copy of the string with all the characters in lowercase.
-   `string.count(substring)`: returns number of occurrences of substring in string.
-   `string.split(char)`: returns a list of values where string is split at the given character. Without a parameter the default split is at every space.
-   `string.find(substring)`: returns the index of the start of the first occurrence of substring within string.
-   `string.isalnum()`: returns boolean depending on whether the string's length is > 0 and all characters are alphanumeric (letters and numbers only). Strings that include spaces and punctuation will return False for this method. Similar methods include  `.isalpha()`,  `.isdigit()`,  `.islower()`,  `.isupper()`, and so on. All return booleans.
-   `string.join(list)`: returns a string that is all strings within our set (in this case a list) concatenated.
-   `string.endswith(substring)`: returns a boolean based upon whether the last characters of string match substring.

It's important to know that we have only introduced you the basics of what we can do with strings. There is a lot more you can do with string interpolation, and every data type has numerous built-in methods. The Python documentation is the best place to look for more information. For example, under section 4.7.1 of  [https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html), you will find the string methods. Have a general idea of the tools we have available to us and try experimenting with them in the shell to see what they can do, but don't spend time trying to memorize them, though. You can always look up whatever you need to use.

# Assignment: Hello World

## Objectives

-   Practice the different ways to concatenate and print strings
-   Practice running a Python file

----------

It's time to start creating Python files! As a rite of passage, our first program needs to be Hello World :). Let’s practice string concatenation. Copy the code below, replacing each of the  `your code here` placeholders with the appropriate values. Hopefully it's not too patronizing that every other task below is running the file--this is just a friendly reminder to get into the habit of testing your code regularly!
```python
# 1. TASK: print "Hello World"
print( your code here )
# 2. print "Hello Noelle!" with the name in a variable
name = "Noelle"
print( your code here )	# with a comma
print( your code here )	# with a +
# 3. print "Hello 42!" with the number in a variable
name = 42
print( your code here )	# with a comma
print( your code here )	# with a +	-- this one should give us an error!
# 4. print "I love to eat sushi and pizza." with the foods in variables
fave_food1 = "sushi"
fave_food2 = "pizza"
print( your code here ) # with .format()
print( your code here ) # with an f string
```
-   [ ] Create a new Python file called hello_world.py
    
- [ ]  Write the code to print a literal string saying "Hello World" (#1)
    
-  [ ] Run the file
    
-  [ ] Store your name in a variable, and then use it to print the string “Hello {{your name}}!” using a comma in the print function (#2a)
    
-  [ ] Run the file
    
-  [ ] Store your name in a variable, and then use it to print the string “Hello {{your name}}!” using a + in the print function (#2b)
    
- [ ]  Run the file
    
-  [ ] Store your favorite number in a variable, and then use it to print the string “Hello {{num}}!” using a comma in the print function (#3a)
    
-  [ ] Run the file
    
-  [ ]  Store your favorite number in a variable, and then use it to print the string “Hello {{num}}!” using a + in the print function (#3b)
    
-  [ ] Run the file
    
-  [ ] NINJA BONUS: Figure out how to resolve the error from above, without changing the + sign to a comma
    
-  [ ] Store 2 of your favorite foods in variables, and then use them to print the string “I love to eat {{food_one}} and {{food_two}}.” with the format method (#4a)
    
- [ ]  Run the file
    
-  [ ] Store 2 of your favorite foods in variables, and then use them to print the string “I love to eat {{food_one}} and {{food_two}}.” with f-strings (#4b)
    
-  [ ] Run the file
    
-  [ ] NINJA BONUS: Spend a few minutes playing around with other string methods to see what’s out there!

# Python Syntax

## Objectives:

-   Understand how whitespace is used in Python
-   Know about the pass statement and when to use it

----------

## Indentation and Line-Endings

Unlike what you may have seen in other languages, like JavaScript, Python has  _no brackets or braces_. Instead, the most important aspect of Python is  **indentation**  to indicate which lines belong to which code blocks.

#### What is a code block?

A code block is a set of lines of code that belong together. For example, the first line of an  `if`  statement gives the condition, but the line(s) that follow explain what we want to happen  _if_  the condition is true. Examples of code block keywords include:

-   `def`  (functions)
-   `if`,  `elif`,  `else`  (conditional statements)
-   `for`,  `while`  (loops)
-   `Class`  (classes)

We'll talk more about each of these in the following modules, but for right now we're focused specifically on syntax. The first line (the one containing the keyword) is not indented, but ends with a colon (:). The lines following that belong to that code block are indented  [4 spaces](https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces). When the code block is over, indent back 4 spaces, like so:
```python
    x = 10
    if x > 50:
    	print("bigger than 50")
    else:
    	print("smaller than 50")
```
We advise that you have your text editor render whitespace, especially while coding in Python. This will place a pale gray dot in each space so you can easily see if you are being consistent with your indentation.

#### Pass

If we start a code block, there must be at least one line of indented code immediately following. If we try to run a file with a hanging code block, we'll get a syntax error. Luckily, Python has provided us with the  _pass_  statement for situations where we know we need the block statement, but we aren't sure what to put in it yet.
```python
class EmptyClass:
    pass
```
```python
for val in my_string:
    pass
```
The  _pass_  statement is a null operation; nothing happens when it executes. The  _pass_  is almost never seen in final production, but can be useful in places where your code has not been completed yet.

# Data Types

## Objectives:

-   Understand common data types we'll encounter as we learn Python
-   Review the syntax for common data types
-   Understand basic type casting

----------

Data type refers to how a given value is classified. Here's a list of the data types that you will likely be using in building web applications:

## Primitive data types

These are the basic building blocks of a language. Most languages have these in common:

-   **Boolean Values**  - Assesses the truth value of something. It has only two values:  _True_  and  _False_  (note the uppercase T and F)
```python
is_hungry = True
has_freckles = False
```
-   **Numbers**  - Integers (whole numbers), floating point numbers (commonly known as decimal numbers), and complex numbers
```python
age = 35 # storing an int
weight = 160.57 # storing a float
```
-   **Strings**  - literal text
```python
name = "Joe Blue"
```
## Composite types

These are collections composed of the above primitive types.

-   **Tuples**  - A type of data that is  **immutable**  (can't be modified after its creation) and can hold a group of values. Tuples can contain mixed data types.
```python
dog = ('Bruce', 'cocker spaniel', 19, False)
print(dog[0])		# output: Bruce
dog[1] = 'dachshund'	# ERROR: cannot be modified ('tuple' object does not support item assignment)
```
-   **Lists**  - A type of data that is mutable and can hold a group of values. Usually meant to store a collection of related data.
```python
empty_list = []
ninjas = ['Rozen', 'KB', 'Oliver']
print(ninjas[2]) 	# output: Oliver
ninjas[0] = 'Francis'
ninjas.append('Michael')
print(ninjas)	# output: ['Francis', 'KB', 'Oliver', 'Michael']
ninjas.pop()
print(ninjas)	# output: ['Francis', 'KB', 'Oliver']
ninjas.pop(1)
print(ninjas)	# output: ['Francis', 'Oliver']
```
-   **Dictionaries**  - A group of key-value pairs. Dictionary elements are indexed by unique keys which are used to access values. When you're ready, you can find more built-in dictionary methods  [here](https://www.w3schools.com/python/python_ref_dictionary.asp).
```python
empty_dict = {}
new_person = {'name': 'John', 'age': 38, 'weight': 160.2, 'has_glasses': False}
new_person['name'] = 'Jack'	# updates if the key exists
new_person['hobbies'] = ['climbing', 'coding']	# adds a key-value pair if the key doesn't exist
print(new_person)	
# output: {'name': 'Jack', 'age': 38, 'weight': 160.2, 'has_glasses': False, 'hobbies': ['climbing', 'coding']}
w = new_person.pop('weight')	# removes the specified key and returns the value
print(w)		# output: 160.2
print(new_person)	
# output: {'name': 'Jack', 'age': 38, 'has_glasses': False, 'hobbies': ['climbing', 'coding']} 
```
## Common Functions

If we're ever unsure of a value or variable's data type, we can use the  `type`  function to find out. For example:
```python
print(type(2.63))		# output: <class 'float'>
print(type(new_person))		# output: <class 'dict'>
```
For data types that have a length attribute (eg. lists, dictionaries, tuples, strings), we can use the  `len`  function to get the length:
```python
print(len(new_person))		# output: 4 (the number of key-value pairs)
print(len('Coding Dojo'))	# output: 11
```
## Type Casting or Explicit Type Conversion

We may find ourselves wanting to change a value's data type from one type to another. For example, in the Hello World assignment, trying to print a string  _plus_  a number resulted in a TypeError. Python doesn't know how to add a string and a number, but it can add two strings together, so if we can  **cast**  the number  _as a string_, then we will be able to "add" the two values together, like so:
```python
print("Hello" + 42)			# output: TypeError
print("Hello" + str(42))		# output: Hello 42
```
Another example may be receiving a string input from a user that we want to treat as a number:
```python
total = 35
user_val = "26"
total = total + user_val		# output: TypeError
total = total + int(user_val)		# total will be 61
```

# Conditional Statements

## Objectives:

-   Know the syntax of conditional statements
-   Understand when to use a conditional statement

----------

Conditional statements allow us to run certain lines of code depending on whether certain conditions are met. These statements control the flow our code is executed by the interpreter. In Python, the keywords for conditional statements are  `if`,  `elif`, and  `else`. Here are some examples:

    x = 12
    if x > 50:
    	print("bigger than 50")
    else:
    	print("smaller than 50")
    # because x is not greater than 50, the second print statement is the only one that will execute
    
    x = 55
    if x > 10:
    	print("bigger than 10")
    elif x > 50:
    	print("bigger than 50")
    else:
    	print("smaller than 10")
    # even though x is greater than 10 and 50, the first true statement is the only one that will execute, so we will only see 'bigger than 10'
    
    if x < 10:
    	print("smaller than 10")
    # nothing happens, because the statement is false 

# Comparison and Logic Operators

Here is a table of the comparison operators you can use in your Python programs.

 | Operator | Description                                                                                | Example                                                                                                                                                          |
 | -------- | ------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 | ==       | Checks if the value of two operands are equal                                              | 1 == 2 => False <br/> 1 == 1 =>True                                                                                                                              |
 | !=       | Checks if the value of two operands are not equal                                          | 1 != 2 => True  <br/>1 != 1 => False                                                                                                                             |
 | >        | Checks if the value of left operand is greater than the value of right operand             | 1 > 2 => False <br/> 2 > 1 => True                                                                                                                               |
 | <        | Checks if the value of left operand is less than the value of right operand                | 1 < 2 => True <br/> 2 < 1 => False                                                                                                                               |
 | >=       | Checks if the value of left operand is greater than or equal to the value of right operand | 1 >= 2 => False <br/> 2 >= 2 => True                                                                                                                             |
 | <=       | Checks if the value of left operand is less than or equal to the value of right operand    | 1 <= 2 => True <br/>2 <= 2 => True                                                                                                                               |
 | and      | Checks that each expression on the left and right are both True                            | (1 <= 2) and (2 <= 3) => True <br/> (1 <= 2) and (2 >= 3) => False <br/> (1 >= 2) and (2 >= 3) => False                                                          |
 | or       | Checks if either the expression on the left or right is True                               | (1 <= 2) or (2 >= 3) => True <br/> (1 <= 2) or (2 <= 3) => True <br/> (1 >= 2) or (2 >= 3) => False                                                              |
 | not      | Reverses the true-false value of the operand                                               | not True => False<br/> not False => True<br/>not 1 >= 2 => True <br/>not 1 <= 2 => False <br/>not (1 <= 2 and 2 >= 3) => True<br/>not 1 <= 2 and 2 >= 3 => False |

# Loops

## Objectives:

-   Understand how to loop through a range of numbers
-   Understand how to loop through a list
-   Understand how to loop through a dictionary
-   Understand how to use a while loop
-   Understand break and continue statements within loops

----------

## For Loops with Range

If we want to iterate through numbers, we can use Python's for loop and range function. Let's learn how this works by comparing how for loops worked in JavaScript:

<img src="https://i.ibb.co/ZBPLY9r/loops.png" alt="loops" border="0" />

Notice that range takes 3 arguments. The first value is where the loop should begin, the second value is where the loop should end (exclusive), and the third value is how to increment the iterator.

The range function actually comes with a few shortcuts. If we know the increment is going to be plus one, we can actually just ignore the third argument. Furthermore, if we know the increment is going to be positive one  _and_  the loop starts at 0, we can also leave off the first argument. In other words, each of the following will result in exactly the same loop:
```python
for x in range(0, 10, 1):
for x in range(0, 10):	# increment of +1 is implied
for x in range(10):	# increment of +1 and start at 0 is implied
```
Note that if you need to specify an increment other than +1, all three arguments are required.
```python
for x in range(0, 10, 2):
    print(x)
# output: 0, 2, 4, 6, 8
for x in range(5, 1, -3):
    print(x)
# output: 5, 2
```
## For Loops through Lists

If we want to iterate through a list, we could use the range function and send in the length of the list as the stopping value, but if we are not interested in the index values and want to just see the values of each item in the list in order, we can actually loop to get the values of the list directly!
```python
my_list = ["abc", 123, "xyz"]
for i in range(0, len(my_list)):
    print(i, my_list[i])
# output: 0 abc, 1 123, 2 xyz
    
# OR 
    
for v in my_list:
    print(v)
# output: abc, 123, xyz
```
## For Loops through Dictionaries

Dictionaries are also iterable. When we iterate through a dictionary, the iterator is each of the  _keys_  of the dictionary.
```python
my_dict = { "name": "Noelle", "language": "Python" }
for k in my_dict:
    print(k)
# output: name, language
```
That means if we want the  _values_  of our dictionary, we might do something like this:
```python
my_dict = { "name": "Noelle", "language": "Python" }
for k in my_dict:
    print(my_dict[k])
# output: Noelle, Python
```
Dictionaries also have a few additional methods that allow us to iterate through them and have the keys and/or values as the iterator. Test these out to get a better understanding:
```python
capitals = {"Washington":"Olympia","California":"Sacramento","Idaho":"Boise","Illinois":"Springfield","Texas":"Austin","Oklahoma":"Oklahoma City","Virginia":"Richmond"}
# another way to iterate through the keys
for key in capitals.keys():
     print(key)
# output: Washington, California, Idaho, Illinois, Texas, Oklahoma, Virginia
#to iterate through the values
for val in capitals.values():
     print(val)
# output: Olympia, Sacramento, Boise, Springfield, Austin, Oklahoma City, Richmond
#to iterate through both keys and values
for key, val in capitals.items():
     print(key, " = ", val)
# output: Washington = Olympia, California = Sacramento, Idaho = Boise, etc
```
## While Loops

**While**  loops are another way of looping  _while_  a certain condition is true.

Remember this  _for_  loop?
```python
for count in range(0,5):
    print("looping - ", count)
```
We can rewrite it as a  _while_  loop:
```python
count = 0
while count < 5:
    print("looping - ", count)
    count += 1
```
The basic syntax for a  _while_  loop looks like this:
```python
while <expression>:
    # do something, including progress towards making the expression False. Otherwise we'll never get out of here!
```
#### Else

There are certain conditions that we give for every loop that we have, but what if the condition was not met and we still would like to do something if that happens? We can then use an  _else_  statement with our while loop. Yes, that is right,  _else_  in a loop.
```python
y = 3
while y > 0:
    print(y)
    y = y - 1
else:
    print("Final else statement")
```
The output would be:

<img src="https://i.ibb.co/Pwjj4KD/Screen-Shot-2018-03-22-at-1-51-46-PM.png" alt="Screen-Shot-2018-03-22-at-1-51-46-PM" border="0" />

Note that this  _else_  code section is only executed if the  _while_  loop runs normally and its conditional is false (whether we never entered the  _while_  loop, or we did but eventually the conditional changed from true to false). If instead our  _while_  loop is exited prematurely because of a  _break_  or  _return_  statement, then the  _else_  code section will never be executed.

## Loop Control

We were introduced to  **control flow**  in the previous tabs with if and else statements.  _Loops_,  _breaks_, and  _continues_  are all a part of control flow as well. Control flow is the cornerstone of most programming languages.

When you want finer control over your loops, use the following statements to do so.

#### Break

The  _break_  statement exits the current loop prematurely, resuming execution at the first post-loop statement. The  _break_  statement can be used in both  _while_  and  _for_  loops.  
  
The most common use for the  _break_  is when some external condition is triggered, requiring a hasty exit from a loop.  
  
When loops are nested, a  _break_  will only exit from the innermost loop.

<img src="https://i.ibb.co/DK9s2ZK/break-Flowchart.jpg" alt="break-Flowchart" border="0" />

```python
for val in "string":
    if val == "i":
        break
    print(val)
# output: s, t, r
```
Notice that when the loop got to the letter "i", we stopped looping.

#### Continue

The  _continue_  statement immediately returns control to the beginning of the loop. In other words, the  _continue_  statement rejects, or skips, all the remaining statements in the current iteration of the loop, and continues normal execution at the top of the loop.  
  
The  _continue_  statement is very useful when you want to skip specific iteration(s), but still keep looping to the end.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/2vSZkTX/continue-Flowchart.jpg" alt="continue-Flowchart" border="0" /></a>

```python
for val in "string":
    if val == "i":
        continue
    print(val)
# output: s, t, r, n, g
# notice, no i in the output, but the loop continued after the i
```
```python
y = 3
while y > 0:
    print(y)
    y = y - 1
    if y == 0:
        break
else:		# only executes on a clean exit from the while loop (i.e. not a break)
   print("Final else statement")
# output: 3, 2, 1
```

# Assignment: For Loops: Basic I

## Objectives:

-   Learn how to use basic for loop statements in Python
-   Practice some basic algorithms in Python

----------

Create a Python file called for_loop_basic1.py that performs the following tasks.

1.  **Basic**  - Print all integers from 0 to 150.
2.  **Multiples of Five**  - Print all the multiples of 5 from 5 to 1,000
3.  **Counting, the Dojo Way**  - Print integers 1 to 100. If divisible by 5, print "Coding" instead. If divisible by 10, print "Coding Dojo".
4.  **Whoa. That Sucker's Huge**  - Add odd integers from 0 to 500,000, and print the final sum.
5.  **Countdown by Fours**  - Print positive numbers starting at 2018, counting down by fours.
6.  **Flexible Counter**  - Set three variables: lowNum, highNum, mult. Starting at lowNum and going through highNum, print only the integers that are a multiple of mult. For example, if lowNum=2, highNum=9, and mult=3, the loop should print 3, 6, 9 (on successive lines)

-   [ ] Create a Python file
    
-   [ ] Basics
    
-  [ ] Multiples of Five
    
-  [ ] Counting, the Dojo Way
    
-  [ ] Whoa. That Sucker's Huge
    
-  [ ] Countdown by Fours
    
-  [ ] Flexible Counter

# Functions

## Objectives:

-   Understand what a function is and why it's important
-   Understand the basic syntax for a Python function
-   Understand parameters and arguments
-   Understand what a return does in a function

----------

A  **function**  is a  **named block of code that we can execute to perform a specific task**. More simply, a function is a list of instructions that we can run at any time and as many times as we would like. If we find something that we seem to be using over and over again, it might be best to have a way to streamline the process. A function:

-   has a name
-   takes in parameters (parenthesis required, parameters optional)
-   perform a series of instructions
-   return something afterwards (will return None if there is no explicit return statement)

Think of the  _function_ as a factory. If we were building a new car we would:

1.  Specify the features (_variables_) needed for creating a car
2.  Send the specific features (pass  _arguments_) to a car manufacturing plant (invoke a  _function_)
3.  The factory (_function_) receives the specifications (_parameters_) and does something with them
4.  The factory sends a car (_return_) back to us, since we sent in the request

![](http://i.imgur.com/6LNWxjs.png)

The factory has all the instructions to build a new car and will perform all the tasks. When you want a new car, all you have to do is call the factory to request a new car.

The advantages of using functions are:

-   Reducing the duplication of code
-   Breaking down complex problems into simpler pieces
-   Improving clarity of code

## Syntax

The  `def`  keyword signifies the declaration of a function. This indicates that the following code is a function and assigns a name to that function, so we can  **call**  it later. Parameters are  **inputs**  the function is expecting and appear inside the parenthesis that follow the function name.

Here's a basic example of a function:
```python
def add(a,b):	# function name: 'add', parameters: a and b
    x = a + b	# process
    return x	# return value: x
```
We have declared a function with the  `def`  keyword, named it  _add_, and specified that it takes two inputs (parameters). If this is all we have in our file, nothing would actually appear to happen if we ran it. To actually run the function, we must execute it by  **invoking**  or  **calling**  it. This is done outside of the function using the function name followed by  **()**. Inside the parenthesis are any values (arguments) the function is expecting as input.

new_val = add(3, 5)    # calling the add function, with arguments 3 and 5
print(new_val)    # the result of the add function gets sent back to and saved into new_val, so we will see 8

Once invoked, a function can give us an output. Some functions take an input and some functions don't give us an output. Even if no output is produced, the code inside the function can alter the program - this is called a side effect. Based upon what we learned above, a function that doesn't return anything would produce no output!

## Parameters and Arguments

We define the input of functions using  **parameters.**  Functions can have as many parameters as we need, including 0. Here we've defined the  _say_hi_  function with one parameter called name:

def say_hi(name):
    print("Hi, " + name)

Now, we can invoke this function by calling its name and passing in the correct number of arguments:

# invoking the function 3 times, passing in one argument each time
say_hi('Michael')
say_hi('Anna')
say_hi('Eli')

Wait, but what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example  **'name' is a parameter**  while  **"Michael", "Anna", and "Eli", are arguments**. We  **define parameters.**  We  **pass in arguments**  into functions.

Here's the output:

![](https://s3.amazonaws.com/General_V88/boomyeah2015/codingdojo/curriculum/content/chapter/Screen_Shot_2018-03-22_at_2.22.46_PM.png)

## Returning Values

So far none of our functions had any value that we could hold onto. In many cases, we would want our function to  **return**  some sort of value that we can use later in our program. The following concept is critical in understanding how to use functions correctly in your code:

It is very important to remember the following:  **a function call is equal to whatever that function returns**. This might not make sense until we see it in action.

Let's modify our original  _say_hi_  function and observe the differences:

def say_hi(name):
    return "Hi " + name
greeting = say_hi("Michael") # the returned value from say_hi function gets assigned to the 'greeting' variable
print(greeting) # this will output 'Hi Michael'

Returning a value from a function allows us to store that value in a variable. In this example, we invoked the  `say_hi`  function with "Michael" and set it to the  _greeting_  variable. When we print  _greeting_  we see that it contains the returned value of the  `say_hi`  function  _- "Hi Michael"_.

Going back to our  `add`  function, recall that it takes two parameters and returns the sum of the parameters.

def add(a, b):
    x = a + b
    return x
sum1 = add(4,6)
sum2 = add(1,4)
sum3 = sum1 + sum2

What do you think the values of sum1, sum2, and sum3 would be?

If you guessed 10, 5, and 15, respectively, good job! sum1 was set to the return value of the add function invoked with 4 and 6 as arguments. Similarly, sum2 was set to the return value of invoking add with 1 and 4. The variable sum3 contains the sum of sum1 and sum2 which is 15. Storing these return values in variables allows us to use the results of our functions throughout the rest of our program.

In our examples you may have noticed that our functions were returning values of different data types. Functions can return any of the data types - strings, numbers, lists, tuples, dictionaries and even other functions!

# Assignment: Functions Basic I

## Objectives:

-   Avoid common mistakes of using functions
-   Really understand how to use T-diagram to correctly predict and debug codes

Intro Video

<iframe width="560" height="315" src="https://www.youtube.com/embed/D9LGvOCaeC4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

For each of the following code snippets, first predict the output (what you will see printed to the terminal). Once you've made a prediction, run the code snippet to see if you are correct!
```py
#1
def a():
    return 5
print(a())
```
```py
#2
def a():
    return 5
print(a()+a())
```
```py
#3
def a():
    return 5
    return 10
print(a())
```
```py
#4
def a():
    return 5
    print(10)
print(a())
```
```py
#5
def a():
    print(5)
x = a()
print(x)
```
```py
#6
def a(b,c):
    print(b+c)
print(a(1,2) + a(2,3))
```
```py
#7
def a(b,c):
    return str(b)+str(c)
print(a(2,5))
```
```py
#8
def a():
    b = 100
    print(b)
    if b < 10:
        return 5
    else:
        return 10
    return 7
print(a())
```	
```py
#9
def a(b,c):
    if b<c:
        return 7
    else:
        return 14
    return 3
print(a(2,3))
print(a(5,3))
print(a(2,3) + a(5,3))
```
```py
#10
def a(b,c):
    return b+c
    return 10
print(a(3,5))
```
```py
#11
b = 500
print(b)
def a():
    b = 300
    print(b)
print(b)
a()
print(b)
```
```py
#12
b = 500
print(b)
def a():
    b = 300
    print(b)
    return b
print(b)
a()
print(b)
```
```py
#13
b = 500
print(b)
def a():
    b = 300
    print(b)
    return b
print(b)
b=a()
print(b)
```
```py
#14
def a():
    print(1)
    b()
    print(2)
def b():
    print(3)
a()
```
```py
#15
def a():
    print(1)
    x = b()
    print(x)
    return 10
def b():
    print(3)
    return 5
y = a()
print(y)
```
-   Create a text file, or copy the code snippets into a Python file
    
-   Predict the output for each of the 15 snippets, checking and comparing your predictions after each snippet
    
-   Submit the text file or Python file with your predictions

# Assignment: Functions Basic II

## Objectives:

-   Learn how to create basic functions in Python
-   Get comfortable using lists
-   Get comfortable having the function return an expression/value

----------

1.  **Countdown**  - Create a function that accepts a number as an input. Return a new list that counts down by one, from the number (as the 0th element) down to 0 (as the last element).

-   Example: countdown(5) should return [5,4,3,2,1,0]

3.  **Print and Return**  - Create a function that will receive a list with two numbers. Print the first value and return the second.

-   Example: print_and_return([1,2]) should print 1 and return 2

5.  **First Plus Length**  - Create a function that accepts a list and returns the sum of the first value in the list plus the list's length.

-   Example: first_plus_length([1,2,3,4,5]) should return 6 (first value: 1 + length: 5)

7.  **Values Greater than Second**  - Write a function that accepts a list and creates a new list containing only the values from the original list that are greater than its 2nd value. Print how many values this is and then return the new list. If the list has less than 2 elements, have the function return False

-   Example: values_greater_than_second([5,2,3,2,1,4]) should print 3 and return [5,3,4]
-   Example: values_greater_than_second([3]) should return False

9.  **This Length, That Value**  - Write a function that accepts two integers as parameters: size and value. The function should create and return a list whose length is equal to the given size, and whose values are all the given value.

-   Example: length_and_value(4,7) should return [7,7,7,7]
-   Example: length_and_value(6,2) should return [2,2,2,2,2,2]

- [ ] Countdown
    
- [ ] Print and Return
    
- [ ]  First Plus Length
    
- [ ]  Values Greater than Second
    
- [ ]  This Length, That Value

# Assignment: For Loop Basic II

## Objectives:

-   Get comfortable writing functions only using basic building blocks of Python (i.e. using your own skills rather than relying on built-ins)
-   Get comfortable using for loops, functions, lists, and other data types

----------

1.  **Biggie Size**  - Given a list, write a function that changes all positive numbers in the list to "big".

-   Example: biggie_size([-1, 3, 5, -5]) returns that same list, but whose values are now [-1, "big", "big", -5]

3.  **Count Positives**  - Given a list of numbers, create a function to replace the last value with the number of positive values. (Note that zero is not considered to be a positive number).

-   Example: count_positives([-1,1,1,1]) changes the original list to [-1,1,1,3] and returns it
-   Example: count_positives([1,6,-4,-2,-7,-2]) changes the list to [1,6,-4,-2,-7,2] and returns it

5.  **Sum Total**  - Create a function that takes a list and returns the sum of all the values in the list.

-   Example: sum_total([1,2,3,4]) should return 10
-   Example: sum_total([6,3,-2]) should return 7

7.  **Average**  - Create a function that takes a list and returns the average of all the values.x

-   Example: average([1,2,3,4]) should return 2.5

9.  **Length**  - Create a function that takes a list and returns the length of the list.

-   Example: length([37,2,1,-9]) should return 4
-   Example: length([]) should return 0

11.  **Minimum**  - Create a function that takes a list of numbers and returns the minimum value in the list. If the list is empty, have the function return False.

-   Example: minimum([37,2,1,-9]) should return -9
-   Example: minimum([]) should return False

13.  **Maximum**  - Create a function that takes a list and returns the maximum value in the list. If the list is empty, have the function return False.

-   Example: maximum([37,2,1,-9]) should return 37
-   Example: maximum([]) should return False

15.  **Ultimate Analysis**  - Create a function that takes a list and returns a dictionary that has the sumTotal, average, minimum, maximum and length of the list.

-   Example: ultimate_analysis([37,2,1,-9]) should return {'sumTotal': 31, 'average': 7.75, 'minimum': -9, 'maximum': 37, 'length': 4 }

17.  **Reverse List**  - Create a function that takes a list and return that list with values reversed. Do this without creating a second list. (This challenge is known to appear during basic technical interviews.)

		-  Example: reverse_list([37,2,1,-9]) should return [-9,1,2,37]

- [ ]  Biggie Size
    
- [ ]  Count Positives
    
- [ ]  Sum Total
    
- [ ]  Average
    
- [ ]  Length
    
- [ ]  Minimum
    
- [ ]  Maximum
    
- [ ]  Ultimate Analysis
    
- [ ]  Reverse List

# Default Parameters & Named Arguments

## Objectives:

-   Know how to use default parameter values
-   Become familiar with Python's random module

----------

## Default Parameters

With the functions we've written so far, we've had to provide the exact number of arguments specified when calling the function. However, if we'd like to allow some of the parameters to be optional to the caller of the function, we can set defaults. Take the following function as an example. The purpose of the function is to take a name and a number and print "good morning {some_name}" to the terminal the given number of times. If no name or number is given, the name is blank and the number is 2, respectively.
```py
def beCheerful(name='', repeat=2):		# set defaults when declaring the parameters
	print(f"good morning {name}\n" * repeat)
beCheerful()				# output: good morning (repeated on 2 lines)
beCheerful("tim")		        # output: good morning tim (repeated on 2 lines)
beCheerful(name="john")			# output: good morning john (repeated on 2 lines)
beCheerful(repeat=6)			# output: good morning (repeated on 6 lines)
beCheerful(name="michael", repeat=5)	# output: good morning michael (repeated on 5 lines)
# NOTE: argument order doesn't matter if we are explicit when sending in our arguments!
beCheerful(repeat=3, name="kb")		# output: good morning kb (repeated on 3 lines)
```
Note all the different ways we are able to call on this one function! Even though our function defines 2 parameters, if:

-   no arguments are provided -- the defaults are used
-   one  _unnamed_  argument provided -- provided value is used as the value for the first parameter, and the second parameter's default value is used
-   one  _named_  argument provided -- provided value is used as the value of the parameter of the same name, and the other parameter's default value is used
-   both  _unnamed_  arguments provided -- values assigned to parameters in order (i.e. what we've been doing up to this point)
-   both  _named_  arguments provided -- values are assigned to associated parameter (and then order doesn't matter!)


<iframe width="560" height="315" src="https://www.youtube.com/embed/u6-vXrHLQow" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>




# Assignment: Functions Intermediate I

## Objectives:

-   Practice using default parameter values
-   Practice passing in named arguments
-   Become familiar with Python's random module

----------

With this concept of default parameters in mind, the goal of this assignment is to write a single function, randInt() that takes up to 2 arguments.

-   If no arguments are provided, the function should return a random integer between 0 and 100.
-   If only a max number is provided, the function should return a random integer between 0 and the max number.
-   If only a min number is provided, the function should return a random integer between the min number and 100
-   If both a min and max number are provided, the function should return a random integer between those 2 values.

Here are a couple of important notes about using random.random() and rounding. (Create this function without using random.randInt() -- we are trying to build that method ourselves for this assignment!)

-   `random.random()`  returns a random floating number between 0.000 and 1.000
-   `random.random() * 50`  returns a random floating number between 0.000 and 50.000
-   `random.random() * 25 + 10`  returns a random floating number between 10.000 and 35.000
-   `round(num)`  returns the rounded integer value of num

Here's a little bit of code to get you started, with some test cases and expected outputs. Test each function call one at a time and a few times each to make sure you're getting the correct range.
```py
import random
def randInt(min=   , max=   ):
    num = random.random()
    return num
#print(randInt()) 		    # should print a random integer between 0 to 100
#print(randInt(max=50)) 	    # should print a random integer between 0 to 50
#print(randInt(min=50)) 	    # should print a random integer between 50 to 100
#print(randInt(min=50, max=500))    # should print a random integer between 50 and 500
```
- [ ]  Complete the randInt function
    
- [ ]  BONUS: account for any edge cases (eg. min > max, max < 0)

# Assignment: Functions Intermediate II

## Objectives:

-   Practice writing functions and looping over dictionaries
-   Achieve a better understanding of how to traverse through a list of dictionaries or through a dictionary of lists

----------

**Note: Avoid using class keywords like int, str, list, and dict as variable/parameter names.**

1.  **Update Values in Dictionaries and Lists**
```py
x = [ [5,2,3], [10,8,9] ] 
students = [
     {'first_name':  'Michael', 'last_name' : 'Jordan'},
     {'first_name' : 'John', 'last_name' : 'Rosales'}
]
sports_directory = {
    'basketball' : ['Kobe', 'Jordan', 'James', 'Curry'],
    'soccer' : ['Messi', 'Ronaldo', 'Rooney']
}
z = [ {'x': 10, 'y': 20} ]
```
1.  Change the value 10 in x to 15. Once you're done, x should now be [ [5,2,3], [15,8,9] ].
2.  Change the last_name of the first student from 'Jordan' to 'Bryant'
3.  In the sports_directory, change 'Messi' to 'Andres'
4.  Change the value 20 in z to 30

5.  **Iterate Through a List of Dictionaries**

Create a function  `iterateDictionary(some_list)`  that, given a list of dictionaries, the function loops through each dictionary in the list and prints each key and the associated value. For example, given the following list:
```py
students = [
         {'first_name':  'Michael', 'last_name' : 'Jordan'},
         {'first_name' : 'John', 'last_name' : 'Rosales'},
         {'first_name' : 'Mark', 'last_name' : 'Guillen'},
         {'first_name' : 'KB', 'last_name' : 'Tonel'}
    ]
iterateDictionary(students) 
# should output: (it's okay if each key-value pair ends up on 2 separate lines;
# bonus to get them to appear exactly as below!)
first_name - Michael, last_name - Jordan
first_name - John, last_name - Rosales
first_name - Mark, last_name - Guillen
first_name - KB, last_name - Tonel
```
3.  **Get Values From a List of Dictionaries**

Create a function  `iterateDictionary2(key_name, some_list)`  that, given a list of dictionaries and a key name, the function prints the value stored in that key for each dictionary. For example, iterateDictionary2('first_name', students) should output:
```
Michael
John
Mark
KB
```
And iterateDictionary2('last_name', students) should output:
```
Jordan
Rosales
Guillen
Tonel
```
15.  **Iterate Through a Dictionary with List Values**

Create a function  `printInfo(some_dict)`  that given a dictionary whose values are all lists, prints the name of each key along with the size of its list, and then prints the associated values within each key's list. For example:
```py
dojo = {
   'locations': ['San Jose', 'Seattle', 'Dallas', 'Chicago', 'Tulsa', 'DC', 'Burbank'],
   'instructors': ['Michael', 'Amy', 'Eduardo', 'Josh', 'Graham', 'Patrick', 'Minh', 'Devon']
}
printInfo(dojo)
# output:
7 LOCATIONS
San Jose
Seattle
Dallas
Chicago
Tulsa
DC
Burbank
    
8 INSTRUCTORS
Michael
Amy
Eduardo
Josh
Graham
Patrick
Minh
Devon
```
- [ ]  1. Update Values in Dictionaries and Lists
    
- [ ]  2. Iterate Through a List of Dictionaries
    
- [ ]  3. Get Values From a List of Dictionaries
    
- [ ]  4. Iterate Through a Dictionary with List Values

# Sorting

## Objectives:

-   Practice sorting algorithms to develop logic skills and prepare for interviews
-   Introduction to code efficiency

----------

You'll find that you won't write your own sorting algorithms in your day-to-day work as a developer. Python, Javascript, and most other languages have built-in sorting functions that are great at adapting to the requirements of a given data set. However, writing your own sorting algorithms is great practice for those who are new to programming because they help you develop better logic and give us an opportunity to consider efficiency.

It's important during technical interviews that you understand basic sorting algorithms, including how to implement them from scratch. Many of our alumni have been asked about sorting algorithms during interviews. If asked to implement a sorting algorithm, your interviewer will expect you to write it from scratch on the whiteboard in 30-50 minutes. These exercises will help those already familiar with fundamental concepts of programming to prepare for technical interviews. In addition, they will require analytical thinking and some review of what constitutes efficient code.

When we talk about efficiency, there's an important concept to remember. The more nesting of loops our code contains, the less efficient it becomes. To start considering a sort algorithm, it is generally mentally easier to loop through our data set several times in order to meet our goal. The first few styles of sorting algorithm we'll look at will require nested loops. Remember, however, every time we nest a loop we are increasing the number of times we have to iterate through a set exponentially. That's fine if our set is 10 items long, but what if it's a hundred, ten thousand, or you're Facebook, and it's several million?

Efficiency is something we should think about every time we write any logic, but don't let it stop you from writing code.  **Write code that works first, and then change it to make it better.**  This is called refactoring, and you'll do it many times as you get better and learn about new tools.

You'll find out more about efficiency by reading about something called  **Big O Notation**. You'll cover this later in algorithms, but be curious and take the initiative to learn concepts on your own. If you don't understand what you read, you will always have an instructor or TA at your disposal to help you better understand.

### Python Swap

The swapping you've done in JavaScript probably looked something like this:
```js
// javascript code below! 
var arr = [1,3,5,7];
var temp = arr[0];
arr[0] = arr[1];
arr[1] = temp;
```
If this code looks like a lot of work for a simple swap, good news! Python provides a one-liner way to swap:
```py
# python code below!
arr = [1,3,5,7]
arr[0], arr[1] = arr[1], arr[0]
```

# Bubble Sort

## Objectives:

-   Execute the famous Bubble Sort

----------

> "What is the most efficient way to sort a million 32-bit integers?" - Google CEO Eric Schmidt  
> "I think the bubble sort would be the wrong way to go." - Senator Barack Obama  
> -- November 2007

Poor Bubble Sort. It gets teased a lot, but it's fundamental to know! Besides, it still has its use cases.

The animation below demonstrates how bubble sort works.

![](http://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif)

## Demonstration
Try it yourself! If you get stuck, here's a video with some tips and guidance.

<iframe width="560" height="315" src="https://www.youtube.com/embed/KNx8BsWgkys" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

# Assignment: Selection Sort

## Objectives:

-   Execute selection sort

----------

If you're given a list with a bunch of numbers and you're supposed to sort the numbers (with the smallest number on the left and the largest number on the right), how would you do this? There are numerous sorting algorithms to sort numbers in the list. We'll introduce one of the simplest sorting algorithm called selection sort.

Selection sort works by iterating through the list, finding the minimum value, and moving it to the beginning of the list. Then, ignoring the first position, which is now sorted, iterate through the list again to find the next minimum value and move it to index 1. This continues until all values are sorted. Here's an animation and a  [video](https://youtu.be/xclLa_BIQMg)  of selection sort:


<iframe width="560" height="315" src="https://www.youtube.com/embed/xclLa_BIQMg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

![](http://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)

-   Write the algorithm for selection sort

# Insertion Sort

## Objectives:

-   Execute insertion sort

----------

Build an algorithm for insertion sort. Please watch the video  [here](https://youtu.be/g9SvfIHBImI)  to understand how insertion sort works and implement the code. Basically, this sort works by starting at index 1, shifting that value to the left until it is sorted relative to all values to the left, and then moving on to the next index position and performing the same shifts until the end of the list is reached. The following animation also shows how insertion sort is done.

<iframe width="560" height="315" src="https://www.youtube.com/embed/g9SvfIHBImI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

![](http://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)

#### Some Tips!

Don't forget to write your plan in a non-programming language first (pseudocode!) and test your base cases before you build your code.

Please refrain from checking other people's code. If your code does NOT work as intended make sure

-   you are writing up your plan first,
-   your plan solves your base case, and
-   your plan solves other base cases you have specified.

Sometimes if you are stuck for too long, you need to just start all over as this can be more efficient to do than dwelling on old code with bugs that are hard to trace.

  

- [ ]  Write the algorithm for insertion sort

# Ternary Operator

## Objectives:

-   Recognize a ternary operator

----------

A ternary operator, or conditional expression, is an operator that takes 3 arguments. Most simply, they are a one line if-else statement. In many languages, we see this same functionality with the symbols  `?`  and  `:`. In Python, the syntax is as follows:
```
<result_if_true> if <condition> else <result_if_false>
```
If you've seen this operator in any other languages, Python's syntax can feel awkward, but with practice it will become easier to use and read. And don't forget that we can always use the traditional if-else statement instead.

Here's an example:
```py
# traditional
if stacks >= 3:
    print('Coding Dojo')
else:
    print('You are not Coding Dojo!')
# ternary
print('Coding Dojo' if stacks >= 3 else 'You are not Coding Dojo!')
```

# Lambdas (optional)

## Objectives:

-   Understand what an anonymous function is and when to use it
-   Recognize the syntax of an anonymous function


<iframe width="560" height="315" src="https://www.youtube.com/embed/KnKkK4s26NA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Another type of function mentioned earlier is the _anonymous_ function. Simply put, an anonymous function is a function without a name. In Python, anonymous functions are created with the **lambda** keyword. These functions are used for various purposes:

-   they are handy in situations where we only need to use the function once
-   they are lightweight when we need to break down complex tasks into small, specific tasks
-   they are convenient as arguments to functions that require functions as parameters

Earlier, we defined the square() function that takes in one parameter (num), squares it and then returns it:
```py
def square(num):
    x = num ** 2
    return x
```
Now we can rewrite this function as an anonymous (nameless) lambda function:
```py
lambda num: num ** 2
```
This means  _"here is an anonymous (nameless) function that takes one argument, called num, and returns num**2._

What if you wanted to create an anonymous (nameless) function that takes two arguments and returns the sum of the two arguments?
```py
lambda num1, num2: num1+num2
```
This means  _"here is an anonymous (nameless) function that takes two arguments: num1, and num2; and returns num1+num2._

A lambda could be:  

**an element in a list:**
```py
# create a new list, with a lambda as an element
my_list = ['test_string', 99, lambda x : x ** 2]
# access the value in the list
print(my_list[2]) # will print a lambda object stored in memory
# invoke the lambda function, passing in 5 as the argument
my_list[2](5)
```
**passed to another function as a callback:**
```py
# define a function that takes one input that is a function
def invoker(callback):
    # invoke the input pass the argument 2
    print(callback(2))
invoker(lambda x: 2 * x)
invoker(lambda y: 5 + y)
```
**stored in a variable:**
```py
add10 = lambda x: x + 10 # store lambda expression in a variable
add10(2)  # returns 12
add10(98) # returns 108
```
**returned by another function:**
```py
def incrementor(num):
    start = num
    return lambda x: num + x
```
### Lambdas & Other Functions

Sometimes when you invoke a function, one of the arguments may need to be a function. This is where lambdas come in handy - a place where you might not want to declare a completely new function with the def keyword. For example, let's talk about the map function which takes in a function and a list as parameters, then applies the function to each element in the list and returns a map object, which can be easily converted to a list. One way we could do this is like this:
```py
# create a list
my_arr = [1,2,3,4,5]
# define a function that squares values
def square(num):
    return num ** 2
# invoke map function
print(list(map(square, my_arr)))
```
The output is:
```py
[1,4,9,16,25]
```
This way is fine and works, but let's say we never use the  _square_ function again in our program. Defining a function simply for that purpose is not quite necessary, which is why  _lambdas are useful  **when we only need a function once**_. This way we don't need to define a function and unnecessarily consume memory and complicate our code, just to produce the same result:
```py
my_arr = [1,2,3,4,5]
print(list(map(lambda x: x ** 2, my_arr))) # invoke map, pass in a lambda as the first argument
```
Functions where this implementation comes into play:

-   map()
-   reduce()
-   sort() - lambda is optional
-   filter()

# Assignment: Underscore

## Objectives:

-   Understand callbacks
-   Practice anonymous functions
-   Create a custom Python module

----------

#### Your own custom Python Module!

Did you know that you can actually create your own custom python module similar to the  [Underscore](http://underscorejs.org/)  library in JavaScript? That may be hard to believe, but in truth, you know how to create significant Python modules of your own. To create a custom Python module, you will simply define several functions, or methods, into a single class! We'll talk about classes soon--for now you can use the code below and follow the pattern for calling the methods as shown below.

You will create the following methods from the underscore library as  **methods**  of the "_" object.  **Pay attention to what you have to change, in terms of parameters for each method as well as implementation.**

In each of the following methods, the first parameter,  **self**, is implicitly passed (again, more on this in the next chapter). The only parameters you need to worry about for now are  **iterable**  and  **callback**.  **Iterable**  will be the list being passed in, and  **callback** will be the lambda function.
```py
class Underscore:
    def map(self, iterable, callback):
        # your code here
    def find(self, iterable, callback):
        # your code here
    def filter(self, iterable, callback):
        # your code
    def reject(self, iterable, callback):
        # your code
# you just created a library with 4 methods!
# let's create an instance of our class
_ = Underscore() # yes we are setting our instance to a variable that is an underscore
evens = _.filter([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0)
# should return [2, 4, 6] after you finish implementing the code above
```
In the code above, you just created your own custom Python module/library that others can use! How can others use the methods in your library? By calling the properties stored in the class you defined (e.g. _.map(), _.find(), etc).

Your assignment is to implement the 4 methods above using callbacks. You will have to modify the 4 methods to take in a list and a callback. A callback is simply a function that is passed as an argument, to be executed by the function to which it is being passed. Just as we are able to pass numbers, lists, strings, etc. when making a function call, we can also pass functions! That means we do not invoke the function right away, but rather pass the function by using the name only (i.e. not including the ()). In the following examples, we are specifically passing lambda functions:
```py
_.map([1,2,3], lambda x: x*2) # should return [2,4,6]
_.find([1,2,3,4,5,6], lambda x: x>4) # should return the first value that is greater than 4
_.filter([1,2,3,4,5,6], lambda x: x%2==0) # should return [2,4,6]
_.reject([1,2,3,4,5,6], lambda x: x%2==0) # should return [1,3,5]
```
One important concept that we want you to learn through this assignment is  **how to pass data to and from callbacks.**  You pass data  **to a callback with a  _parameter_**  and you pass data  **from the callback back to the parent function with a  _return_.**  While you are going through this assignment pay close attention to this relationship.

To understand what each method does, please refer to the  [underscore library](http://underscorejs.org/).  **Note that your method does not have to be as robust; you just need to get the base functionality working. For most methods, you will only have the list and a lambda as parameters, and for the lambda you will pass in each element and potentially a "memo" also known as a "collector".**

Note that some of these functions already exist in Python. As with many algorithm challenges, we want you to explore how you might implement these yourself. Be aware that these tools exist to help work in a design idiom known as "functional programming." It's not something that we cover here, but is a topic you may want to explore on your own. It is mainly used in data science in recent years.

- [ ]  Complete the map method
    
- [ ]  Complete the find method
    
- [ ]  Complete the filter method
    
- [ ]  Complete the reject method

# Sequences

## Objectives:

-   Get familiar with slicing lists and tuples
-   Learn a few built-in sequence methods

----------

## What are sequences?

**Sequences**  are anything over which we can iterate sequentially, including lists, tuples, and strings. Here we'll learn about a few neat things we can do with instances of these classes.

## Slicing

If we're interested in getting subsets of values from a sequence, Python provides a way for slicing with  `[:]`. We indicate the starting index on the left and the ending index (exclusive) on the right. If we don't indicate a value on the left, it will start at index 0; if the value on the right is not specified, it will assume the length of the sequence. Like the slice method in JavaScript, utilizing this syntax returns a copy of the data type with the specified values.
```py
my_list = [99,4,2,5,-3]
my_tuple = (99,4,2,5,-3)
my_str = "sequoia"
print(my_list[:])
# output: [99,4,2,5,-3]
print(my_tuple[1:])
# output: (4,2,5,-3)
print(my_str[:3])
# output: "seq"
print(my_tuple[2:4])
# output: (2,5)
print(my_list, my_tuple, my_str)
# output: [99,4,2,5,-3] (99,4,2,5,-3) 'sequoia' -- note the original values have not changed
```
Other Built-In Sequence Methods

Here are a few commonly used built-in functions for sequences:

-   `max(sequence)`  returns the largest value in the sequence
-   `sum(sequence)`  returns the sum of all values in sequence
-   `map(function, sequence)`  applies the function to every item in the sequence you pass in. Returns a list of the results.
-   `min(sequence)`  returns the lowest value in a sequence.
-   `sorted(sequence)`  returns a sorted list of the sequence's values

Click  [here](http://www.linuxtopia.org/online_books/programming_books/python_programming/python_ch14s07.html)  to learn more about other built-in functions you can use with sequences.

# Assignment: Facial Recognition

Python has many great libraries. One great library is called OpenCV where you can do cool facial recognition tricks. Please take a few minutes to quickly go over the following two articles.  

-   [https://realpython.com/face-recognition-with-python/](https://realpython.com/face-recognition-with-python/)
-   [https://realpython.com/face-detection-in-python-using-a-webcam/](https://realpython.com/face-detection-in-python-using-a-webcam/)

Building a project with a simple facial recognition is not only fun, but with additional features, could be a solid project you could add to your portfolio.

To install opencv, you may need to run

pip install opencv-python

Note that you need to clone the codes in the Git repository (outlined in the tutorial) to access all the files needed in the tutorial.

## Short Video Demo

<iframe width="560" height="315" src="https://www.youtube.com/embed/VCAUX0rPY4M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>